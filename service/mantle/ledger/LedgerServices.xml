<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.0.xsd">

    <service verb="create" noun="GlAccount" type="entity-auto">
        <in-parameters>
            <auto-parameters entity-name="mantle.ledger.account.GlAccount"/>
            <parameter name="glAccountId" default="accountCode"/>
            <parameter name="accountCode" required="true"/>
            <parameter name="accountName" required="true"/>
            <parameter name="glAccountClassEnumId" required="true"/>
            <parameter name="glResourceTypeEnumId" default-value="GlrtMoney"/>
        </in-parameters>
        <out-parameters><parameter name="glAccountId"/></out-parameters>
    </service>

    <service verb="init" noun="PartyAccountingConfiguration">
        <in-parameters>
            <parameter name="sourcePartyId" required="true"/>
            <parameter name="organizationPartyId" required="true"/>
            <auto-parameters entity-name="mantle.ledger.config.PartyAcctgPreference" include="nonpk"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="existingPartyAcctgPreference">
                <field-map field-name="organizationPartyId"/>
            </entity-find-one>
            <if condition="existingPartyAcctgPreference">
                <return message="Party [${organizationPartyId}] already has a PartyAcctgPreference record, so not initializing accounting configuration."/>
            </if>

            <!-- create an error Journal mantle.ledger.transaction.GlJournal -->
            <entity-find-one entity-name="mantle.party.Organization" value-field="organization">
                <field-map field-name="partyId" from="organizationPartyId"/></entity-find-one>
            <set field="errorGlJournalId" value="${organizationPartyId}Error"/>
            <service-call name="create#mantle.ledger.transaction.GlJournal"
                    in-map="[organizationPartyId:organizationPartyId, glJournalId:errorGlJournalId,
                        glJournalTypeEnumId:'GLJRNL_ERROR', isPosted:'N',
                        glJournalName:('Error Journal for ' + (organization?.organizationName ?: organizationPartyId))]"/>

            <!-- copy the mantle.ledger.config.PartyAcctgPreference -->
            <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="sourcePartyAcctgPreference">
                <field-map field-name="organizationPartyId" from="sourcePartyId"/>
            </entity-find-one>
            <if condition="!sourcePartyAcctgPreference"><return error="true" message="Could not find PartyAcctgPreference for source party [${sourcePartyId}]"/></if>
            <set field="partyAcctgPreference" from="sourcePartyAcctgPreference.cloneValue()"/>
            <entity-set value-field="partyAcctgPreference" include="nonpk" set-if-empty="false"/>
            <service-call name="create#mantle.ledger.config.PartyAcctgPreference"
                    in-map="partyAcctgPreference + [organizationPartyId:organizationPartyId, errorGlJournalId:errorGlJournalId]"/>

            <!-- copy mantle.ledger.account.GlAccountOrganization -->
            <entity-find entity-name="mantle.ledger.account.GlAccountOrganization" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.AssetTypeGlAccount -->
            <entity-find entity-name="mantle.ledger.config.AssetTypeGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record">
                <set field="record.organizationPartyId" from="organizationPartyId"/>
                <set field="record.assetTypeGlAccountId" from="null"/>
                <entity-sequenced-id-primary value-field="record"/>
                <entity-create value-field="record"/>
            </iterate>

            <!-- copy mantle.ledger.config.GlAccountTypeDefault -->
            <entity-find entity-name="mantle.ledger.config.GlAccountTypeDefault" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.InvoiceTypeTransType -->
            <entity-find entity-name="mantle.ledger.config.InvoiceTypeTransType" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.ItemTypeGlAccount -->
            <entity-find entity-name="mantle.ledger.config.ItemTypeGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.PaymentTypeGlAccount -->
            <entity-find entity-name="mantle.ledger.config.PaymentTypeGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.PaymentInstrumentGlAccount -->
            <entity-find entity-name="mantle.ledger.config.PaymentInstrumentGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.FinancialAccountTypeGlAccount -->
            <entity-find entity-name="mantle.ledger.config.FinancialAccountTypeGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>
            <!-- copy mantle.ledger.config.FinancialAccountReasonGlAccount -->
            <entity-find entity-name="mantle.ledger.config.FinancialAccountReasonGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- TODO: CreditCardTypeGlAccount, GlAccountTypePartyDefault, ProductCategoryGlAccount, ProductGlAccount, TaxAuthorityGlAccount, VarianceReasonGlAccount -->

            <!-- setup mantle.party.time.TimePeriod for FiscalMonth, FiscalQuarter, FiscalYear -->
            <service-call name="mantle.ledger.LedgerServices.check#NextFiscalTimePeriods"
                    in-map="[organizationPartyId:organizationPartyId]"/>
        </actions>
    </service>

    <service verb="find" noun="PartyAcctgPreference">
        <description>Get the PartyAcctgPreference record for the specified organizationPartyId and if not found find
            record for ancestor organization(s).</description>
        <in-parameters><parameter name="organizationPartyId" required="true"/></in-parameters>
        <out-parameters><parameter name="partyAcctgPreference" type="EntityValue"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="partyAcctgPreference" cache="true">
                <field-map field-name="organizationPartyId"/></entity-find-one>

            <if condition="!partyAcctgPreference">
                <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                    <date-filter/>
                    <econdition field-name="fromPartyId" from="organizationPartyId"/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                    <econdition field-name="toRoleTypeId" value="OrgInternal"/>
                </entity-find>
                <if condition="partyRelationshipList">
                    <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                            in-map="[organizationPartyId:partyRelationshipList[0].toPartyId]"/>
                </if>
            </if>
        </actions>
    </service>
    <service verb="find" noun="RootGlAccountClassEnum">
        <in-parameters><parameter name="glAccountClassEnumId"/></in-parameters>
        <out-parameters><parameter name="rootGlAccountClassEnumId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue" cache="true">
                <field-map field-name="enumId" from="glAccountClassEnumId"/>
            </entity-find-one>
            <if condition="enumValue.parentEnumId"><then>
                <service-call name="mantle.ledger.LedgerServices.find#RootGlAccountClassEnum" out-map="context"
                        in-map="[glAccountClassEnumId:enumValue.parentEnumId]"/>
            </then><else>
                <set field="rootGlAccountClassEnumId" from="glAccountClassEnumId"/>
            </else></if>
        </actions>
    </service>
    <service verb="expand" noun="ParentOrganizationList">
        <in-parameters><parameter name="organizationPartyId" required="true"/></in-parameters>
        <out-parameters><parameter name="orgPartyIdList" type="List"/></out-parameters>
        <actions>
            <set field="orgPartyIdList" from="[organizationPartyId]"/>

            <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                <date-filter/>
                <econdition field-name="fromPartyId" from="organizationPartyId"/>
                <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                <econdition field-name="toRoleTypeId" value="OrgInternal"/>
            </entity-find>
            <iterate list="partyRelationshipList" entry="partyRelationship">
                <service-call name="mantle.ledger.LedgerServices.expand#ParentOrganizationList" out-map="expandResult"
                        in-map="[organizationPartyId:partyRelationship.toPartyId]"/>
                <script>orgPartyIdList.addAll(expandResult.orgPartyIdList)</script>
            </iterate>
        </actions>
    </service>
    <service verb="expand" noun="ChildOrganizationList">
        <in-parameters>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="onlyWithNoAcctgPreference" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters><parameter name="orgPartyIdList" type="List"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="partyAcctgPreference" cache="true">
                <field-map field-name="organizationPartyId"/></entity-find-one>
            <if condition="onlyWithNoAcctgPreference &amp;&amp; partyAcctgPreference"><then>
                <set field="orgPartyIdList" from="[]"/>
            </then><else>
                <set field="orgPartyIdList" from="[organizationPartyId]"/>
            </else></if>

            <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                <date-filter/>
                <econdition field-name="toPartyId" from="organizationPartyId"/>
                <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                <econdition field-name="toRoleTypeId" value="OrgInternal"/>
            </entity-find>
            <iterate list="partyRelationshipList" entry="partyRelationship">
                <if condition="onlyWithNoAcctgPreference">
                    <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="partyAcctgPreference" cache="true">
                        <field-map field-name="organizationPartyId" from="partyRelationship.fromPartyId"/></entity-find-one>
                    <if condition="partyAcctgPreference"><continue/></if>
                </if>
                <service-call name="mantle.ledger.LedgerServices.expand#ChildOrganizationList" out-map="expandResult"
                        in-map="[organizationPartyId:partyRelationship.fromPartyId, onlyWithNoAcctgPreference:onlyWithNoAcctgPreference]"/>
                <script>orgPartyIdList.addAll(expandResult.orgPartyIdList)</script>
            </iterate>
        </actions>
    </service>

    <service verb="get" noun="DefaultGlAccountByType">
        <in-parameters>
            <parameter name="glAccountTypeEnumId" required="true"/>
            <!-- <parameter name="acctgTransTypeEnumId" required="true"/> -->
            <parameter name="organizationPartyId" required="true"/>
            <!-- <parameter name="otherPartyId"/> -->
        </in-parameters>
        <out-parameters>
            <parameter name="glAccountId"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.ledger.config.GlAccountTypeDefault" list="glAccountTypeDefaultList" cache="true">
                <econdition field-name="organizationPartyId"/>
                <econdition field-name="glAccountTypeEnumId"/>
            </entity-find>
            <set field="glAccountId" from="glAccountTypeDefaultList.first?.glAccountId"/>

            <if condition="!glAccountId">
                <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                    <date-filter/>
                    <econdition field-name="fromPartyId" from="organizationPartyId"/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                    <econdition field-name="toRoleTypeId" value="OrgInternal"/>
                </entity-find>
                <if condition="partyRelationshipList">
                    <service-call name="mantle.ledger.LedgerServices.get#DefaultGlAccountByType" out-map="context"
                            in-map="[organizationPartyId:partyRelationshipList[0].toPartyId,
                                glAccountTypeEnumId:glAccountTypeEnumId]"/>
                </if>
            </if>
        </actions>
    </service>

    <!-- ============================================================ -->
    <!-- ========== Manual Accounting Transaction Services ========== -->
    <!-- ============================================================ -->

    <service verb="create" noun="AcctgTrans">
        <in-parameters>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTrans" include="nonpk">
                <exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
            <parameter name="acctgTransTypeEnumId" required="true"/>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="transactionDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="amountUomId" default-value="USD"/>
            <parameter name="glFiscalTypeEnumId" default-value="GLFT_ACTUAL"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransId"/></out-parameters>
        <actions>
            <set field="isPosted" value="N"/>
            <service-call name="create#mantle.ledger.transaction.AcctgTrans" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="AcctgTrans">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTrans" include="nonpk">
                <exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>
            <if condition="acctgTrans.isPosted == 'Y'"><return error="true" message="Cannot update transaction [${acctgTransId}], already posted."/></if>
            <service-call name="update#mantle.ledger.transaction.AcctgTrans" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="delete" noun="AcctgTrans">
        <in-parameters><parameter name="acctgTransId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>

            <if condition="acctgTrans.isPosted == 'Y'">
                <return error="true" message="Not deleting transaction [${acctgTransId}], transaction is posted"/></if>

            <entity-delete-by-condition entity-name="mantle.ledger.transaction.AcctgTransEntry">
                <econdition field-name="acctgTransId"/></entity-delete-by-condition>
            <entity-delete value-field="acctgTrans"/>
        </actions>
    </service>

    <service verb="create" noun="AcctgTransEntry">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="acctgTrans" type="EntityValue"/>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTransEntry" include="nonpk"/>
            <parameter name="debitCreditFlag" required="true"/>
            <parameter name="amount" type="BigDecimal" required="true"/>
            <!-- allow setting this to be deferred <parameter name="glAccountId" required="true"/> -->
            <parameter name="reconcileStatusId" default-value="AterNot"/>
            <parameter name="isSummary" default-value="N"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransEntrySeqId"/></out-parameters>
        <actions>
            <if condition="!acctgTrans"><entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/></if>
            <if condition="acctgTrans.isPosted == 'Y'"><return error="true" message="Cannot create entry for transaction [${acctgTransId}], already posted."/></if>
            <if condition="amount &lt; 0">
                <!-- if negative abs the amount and reverse the debit/credit flag -->
                <set field="amount" from="amount.abs()"/>
                <set field="debitCreditFlag" from="debitCreditFlag == 'D' ? 'C' : 'D'"/>
            </if>
            <service-call name="create#mantle.ledger.transaction.AcctgTransEntry" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="AcctgTransEntry">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="acctgTransEntrySeqId" required="true"/>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTransEntry" include="nonpk"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>
            <if condition="acctgTrans.isPosted == 'Y'"><return error="true" message="Cannot update entry for transaction [${acctgTransId}], already posted."/></if>
            <service-call name="update#mantle.ledger.transaction.AcctgTransEntry" in-map="context"/>
        </actions>
    </service>
    <service verb="delete" noun="AcctgTransEntry">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="acctgTransEntrySeqId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>
            <if condition="acctgTrans.isPosted == 'Y'"><return error="true" message="Cannot delete entry for transaction [${acctgTransId}], already posted."/></if>
            <service-call name="delete#mantle.ledger.transaction.AcctgTransEntry" in-map="context"/>
        </actions>
    </service>

    <!-- ================================================= -->
    <!-- ========== AcctgTrans Posting Services ========== -->
    <!-- ================================================= -->

    <service verb="calculate" noun="AcctgTransTrialBalance">
        <description>Add up debits and credits for an AcctgTrans and get the difference.</description>
        <in-parameters><parameter name="acctgTransId" required="true"/></in-parameters>
        <out-parameters>
            <parameter name="debitTotal" type="BigDecimal"/>
            <parameter name="creditTotal" type="BigDecimal"/>
            <parameter name="debitCreditDifference" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.ledger.transaction.AcctgTransEntry" list="acctgTransEntryList">
                <econdition field-name="acctgTransId"/>
                <order-by field-name="acctgTransEntrySeqId"/>
            </entity-find>
            <set field="debitTotal" from="0"/>
            <set field="creditTotal" from="0"/>
            <iterate entry="acctgTransEntry" list="acctgTransEntryList">
                <if condition="acctgTransEntry.debitCreditFlag == 'D'"><then>
                    <set field="debitTotal" from="debitTotal + acctgTransEntry.amount"/>
                </then><else>
                    <set field="creditTotal" from="creditTotal + acctgTransEntry.amount"/>
                </else></if>
            </iterate>

            <set field="debitCreditDifference" from="debitTotal - creditTotal"/>
        </actions>
    </service>
    <service verb="post" noun="AcctgTrans">
        <description>Posts an Accounting Transaction (AcctgTrans) after verifying it is ready for posting (with
            verify#AcctgTrans service).</description>
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="verifyOnly" type="Boolean" default="false"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>
            <entity-find entity-name="mantle.ledger.transaction.AcctgTransEntry" list="acctgTransEntryList">
                <econdition field-name="acctgTransId"/><order-by field-name="acctgTransEntrySeqId"/></entity-find>

            <!-- make sure the AcctgTrans has not already been posted -->
            <if condition="acctgTrans.isPosted == 'Y'">
                <return error="true" message="Not posting transaction [${acctgTransId}], already posted."/></if>

            <set field="useErrorJournal" from="false"/>

            <!-- check the scheduled posting date, but only if it's set -->
            <if condition="acctgTrans.scheduledPostingDate != null &amp;&amp; ec.user.nowTimestamp.before(acctgTrans.scheduledPostingDate)">
                <message>Not posting transaction ${acctgTransId}, before scheduled posting date.</message>
                <set field="useErrorJournal" from="true"/>
            </if>

            <!-- check trial balance -->
            <service-call name="mantle.ledger.LedgerServices.calculate#AcctgTransTrialBalance" out-map="context"
                    in-map="[acctgTransId:acctgTransId]"/>
            <if condition="debitTotal != creditTotal">
                <message>Not posting transaction ${acctgTransId}, credit total ${creditTotal} and debit total ${debitTotal} not equal.</message>
                <set field="useErrorJournal" from="true"/>
            </if>

            <!-- get GlAccount records, make sure accounts allow posting -->
            <set field="glAccountById" from="new TreeMap()"/>
            <iterate list="acctgTransEntryList" entry="acctgTransEntry">
                <set field="glAccount" from="glAccountById.get(acctgTransEntry.glAccountId)"/>
                <if condition="!glAccount">
                    <entity-find-one entity-name="mantle.ledger.account.GlAccount" value-field="glAccount" cache="true">
                        <field-map field-name="glAccountId" from="acctgTransEntry.glAccountId"/></entity-find-one>
                    <script>glAccountById.put(acctgTransEntry.glAccountId, glAccount)</script>
                </if>

                <if condition="glAccount.disallowPosting == 'Y'">
                    <message>GL Account ${glAccount.glAccountId} does not allow posting</message>
                    <log level="info" message="In AcctgTransEntry ${acctgTransId}:${acctgTransEntry.acctgTransEntrySeqId} GL Account ${glAccount.glAccountId} does not allow posting"/>
                    <set field="useErrorJournal" from="true"/>
                </if>
            </iterate>

            <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                          in-map="[organizationPartyId:acctgTrans.organizationPartyId]"/>
            <set field="doRealTimeGlSummary" from="partyAcctgPreference?.realTimeGlSummary == 'Y'"/>

            <if condition="useErrorJournal">
                <if condition="partyAcctgPreference?.errorGlJournalId"><then>
                    <service-call name="update#mantle.ledger.transaction.AcctgTrans"
                                  in-map="[acctgTransId:acctgTransId, glJournalId:partyAcctgPreference.errorGlJournalId]"/>
                    <message>Accounting transaction ${acctgTransId} has been saved in Error Journal ${partyAcctgPreference.errorGlJournalId}.</message>
                    <return/>
                </then><else>
                    <!-- if no errorGlJournalId return error -->
                    <return error="true" message="No error journal, returning error instead"/>
                </else></if>
            </if>

            <!-- get current period(s) and check if closed (also include parent organizations) -->
            <service-call name="mantle.ledger.LedgerServices.get#OrganizationFiscalTimePeriods" out-map="context"
                    in-map="[organizationPartyId:acctgTrans.organizationPartyId, filterDate:acctgTrans.transactionDate]"/>
            <if condition="!timePeriodList">
                <message error="true">Not posting transaction ${acctgTransId}, could not find time current period for organization ${acctgTrans.organizationPartyId}.</message></if>
            <set field="subsequentPeriodListArray" from="new ArrayList()"/>
            <iterate entry="timePeriod" list="timePeriodList">
                <!-- DEJ 20160406 don't lock TimePeriod, shouldn't be needed
                <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="lockTimePeriod" for-update="true">
                    <field-map field-name="timePeriodId" from="timePeriodFromList.timePeriodId"/></entity-find-one>
                -->

                <!-- make sure the TimePeriod isn't closed -->
                <if condition="timePeriod.isClosed == 'Y'">
                    <message error="true">Not posting transaction ${acctgTransId}, time period closed ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}.</message></if>

                <!-- get any existing subsequent time periods to update those as well -->
                <if condition="doRealTimeGlSummary"><script>
                    List subsequentPeriodIds = []
                    subsequentPeriodListArray.add(subsequentPeriodIds)
                    String curSubPeriodId = timePeriod.timePeriodId
                    while (curSubPeriodId) {
                        Map subNextResult = ec.service.sync().name("mantle.party.TimeServices.get#NextTimePeriod")
                                .parameter("timePeriodId", curSubPeriodId).call()
                        curSubPeriodId = subNextResult.nextTimePeriodId
                        if (curSubPeriodId) subsequentPeriodIds.add(curSubPeriodId)
                    }
                </script></if>
            </iterate>

            <!-- make sure the glAccountId and amount fields are set -->
            <iterate entry="acctgTransEntry" list="acctgTransEntryList">
                <if condition="!acctgTransEntry.glAccountId">
                    <message error="true">Accounting transaction entry ${acctgTransId}:${acctgTransEntry.acctgTransEntrySeqId} has no glAccountId.</message></if>
                <if condition="acctgTransEntry.amount == null">
                    <message error="true">Accounting transaction entry ${acctgTransId}:${acctgTransEntry.acctgTransEntrySeqId} has no amount.</message></if>
            </iterate>

            <if condition="verifyOnly">
                <if condition="!ec.message.hasError()"><message>Accounting transaction ${acctgTransId} is verified for posting.</message></if>
                <return/>
            </if>

            <if condition="ec.message.hasError()">
                <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                        in-map="[organizationPartyId:acctgTrans.organizationPartyId]"/>
                <if condition="partyAcctgPreference?.errorGlJournalId"><then>
                    <service-call name="update#mantle.ledger.transaction.AcctgTrans"
                            in-map="[acctgTransId:acctgTransId, glJournalId:partyAcctgPreference.errorGlJournalId]"/>
                    <message>Accounting transaction ${acctgTransId} has been saved in Error Journal ${partyAcctgPreference.errorGlJournalId}.</message>
                    <script>ec.message.clearErrors()</script>
                    <return/>
                </then><else>
                    <!-- if not errorGlJournalId return errors -->
                    <check-errors/>
                </else></if>
            </if>

            <!-- only update GlAccountOrganization and GlAccountOrgTimePeriod if realTimeGlSummary == Y; there is now a job that
                periodically updates these records to simplify GL posting and avoid lock contention and conflicts -->
            <if condition="doRealTimeGlSummary">
                <!-- get and lock the GlAccountOrganization (for update); iterate over glAccountById which is a TreeMap so
                    IDs are sorted for consistent lock order (avoid deadlocks) -->
                <set field="glAccountOrganizationById" from="[:]"/>
                <iterate list="glAccountById.keySet()" entry="glAccountId">
                    <entity-find-one entity-name="mantle.ledger.account.GlAccountOrganization" value-field="glAccountOrganization" for-update="true">
                        <field-map field-name="glAccountId"/><field-map field-name="organizationPartyId" from="acctgTrans.organizationPartyId"/></entity-find-one>
                    <if condition="glAccountOrganization == null">
                        <!-- lock on the GlAccount since we can't on the GlAccountOrganization we are creating, and then query again to see if exists -->
                        <entity-find-one entity-name="mantle.ledger.account.GlAccount" value-field="glAccount" for-update="true"/>
                        <entity-find-one entity-name="mantle.ledger.account.GlAccountOrganization" value-field="glAccountOrganization" for-update="true">
                            <field-map field-name="glAccountId"/><field-map field-name="organizationPartyId" from="acctgTrans.organizationPartyId"/></entity-find-one>
                        <if condition="glAccountOrganization == null">
                            <entity-make-value entity-name="mantle.ledger.account.GlAccountOrganization" value-field="glAccountOrganization"
                                               map="[glAccountId:glAccountId, organizationPartyId:acctgTrans.organizationPartyId]"/>
                            <entity-create value-field="glAccountOrganization"/>
                        </if>
                    </if>
                    <script>glAccountOrganizationById.put(glAccountId, glAccountOrganization)</script>
                </iterate>

                <!-- for each entry update posted balance -->
                <iterate list="acctgTransEntryList" entry="acctgTransEntry">
                    <set field="glAccountOrganization" from="glAccountOrganizationById.get(acctgTransEntry.glAccountId)"/>

                    <!-- Debits add to debit accounts and subtract from credit accounts. Credits add to credit accounts and subtract from debit accounts. -->
                    <set field="postingAmount" from="0.0"/>
                    <!-- have already iterated through the entry list once, all GlAccount records should be there -->
                    <set field="glAccount" from="glAccountById.get(acctgTransEntry.glAccountId)"/>
                    <service-call name="mantle.ledger.LedgerServices.find#RootGlAccountClassEnum" out-map="context"
                                  in-map="[glAccountClassEnumId:glAccount.glAccountClassEnumId]"/>

                    <if condition="rootGlAccountClassEnumId == 'DEBIT'"><then>
                        <set field="postingAmount" from="acctgTransEntry.debitCreditFlag == 'D' ? acctgTransEntry.amount : -acctgTransEntry.amount"/>
                    </then><else>
                        <set field="postingAmount" from="acctgTransEntry.debitCreditFlag == 'D' ? -acctgTransEntry.amount : acctgTransEntry.amount"/>
                    </else></if>

                    <!-- FUTURE: do anything with RESOURCE or potentially other root GL account classes? -->

                    <set field="glAccountOrganization.postedBalance" from="(glAccountOrganization.postedBalance ?: 0) + postingAmount"/>
                    <set field="glAccountOrganization.balanceLastUpdated" from="ec.user.nowTimestamp"/>
                    <entity-update value-field="glAccountOrganization"/>

                    <!-- create or update GlAccountOrgTimePeriod records -->
                    <iterate list="timePeriodList" entry="timePeriod">
                        <entity-find-one entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="glAccountOrgTimePeriod" for-update="true">
                            <field-map field-name="glAccountId" from="acctgTransEntry.glAccountId"/>
                            <field-map field-name="organizationPartyId" from="acctgTrans.organizationPartyId"/>
                            <field-map field-name="timePeriodId" from="timePeriod.timePeriodId"/>
                        </entity-find-one>
                        <if condition="glAccountOrgTimePeriod == null">
                            <!-- lock on the GlAccountOrganization since we can't on the GlAccountOrgTimePeriod we are creating, and then query again to see if exists -->
                            <entity-find-one entity-name="mantle.ledger.account.GlAccountOrganization" value-field="glAccountOrgTemp" for-update="true">
                                <field-map field-name="glAccountId" from="acctgTransEntry.glAccountId"/>
                                <field-map field-name="organizationPartyId" from="acctgTrans.organizationPartyId"/>
                            </entity-find-one>
                            <entity-find-one entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="glAccountOrgTimePeriod" for-update="true">
                                <field-map field-name="glAccountId" from="acctgTransEntry.glAccountId"/>
                                <field-map field-name="organizationPartyId" from="acctgTrans.organizationPartyId"/>
                                <field-map field-name="timePeriodId" from="timePeriod.timePeriodId"/>
                            </entity-find-one>
                            <if condition="glAccountOrgTimePeriod == null">
                                <entity-make-value entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="glAccountOrgTimePeriod"
                                                   map="[glAccountId:acctgTransEntry.glAccountId,  organizationPartyId:acctgTrans.organizationPartyId,
                                        timePeriodId:timePeriod.timePeriodId, beginningBalance:0, postedDebits:0, postedCredits:0, endingBalance:0]"/>
                            </if>
                        </if>

                        <if condition="acctgTransEntry.debitCreditFlag == 'D'"><then>
                            <set field="glAccountOrgTimePeriod.postedDebits" from="(glAccountOrgTimePeriod.postedDebits ?: 0) + acctgTransEntry.amount"/>
                        </then><else>
                            <set field="glAccountOrgTimePeriod.postedCredits" from="(glAccountOrgTimePeriod.postedCredits ?: 0) + acctgTransEntry.amount"/>
                        </else></if>

                        <set field="glAccountOrgTimePeriod.endingBalance" from="(glAccountOrgTimePeriod.endingBalance ?: 0) + postingAmount"/>

                        <set field="glAccountOrgTimePeriod.balanceLastUpdated" from="ec.user.nowTimestamp"/>
                        <entity-create value-field="glAccountOrgTimePeriod" or-update="true"/>

                        <!-- update period begin and end balances on posting, not just on closing (recalc and reset on period close) -->
                        <set field="subsequentPeriodList" from="subsequentPeriodListArray.get(timePeriod_index)"/>
                        <set field="lastGlAccountOrgTimePeriod" from="glAccountOrgTimePeriod"/>
                        <!-- NOTE: this iterate block very similar to one in recalculate#GlAccountOrgTimePeriodAmounts, perhaps refactor into service -->
                        <iterate list="subsequentPeriodList" entry="subsequentPeriodId">
                            <!-- for each GlAccountOrgTimePeriod record for current period, set beginning balance for next period
                                (creating new records if they don't exist) -->
                            <entity-find-one entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="nextGlAccountOrgTimePeriod" for-update="true">
                                <field-map field-name="glAccountId" from="acctgTransEntry.glAccountId"/>
                                <field-map field-name="organizationPartyId" from="timePeriod.partyId"/>
                                <field-map field-name="timePeriodId" from="subsequentPeriodId"/>
                            </entity-find-one>
                            <if condition="nextGlAccountOrgTimePeriod == null">
                                <entity-make-value entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="nextGlAccountOrgTimePeriod"
                                                   map="[glAccountId:glAccountOrgTimePeriod.glAccountId,  organizationPartyId:timePeriod.partyId,
                                    timePeriodId:subsequentPeriodId, beginningBalance:0, postedDebits:0, postedCredits:0, endingBalance:0]"/>
                            </if>
                            <!-- add endingBalance to both just in case something has already been posted and added to next endingBalance -->
                            <set field="nextGlAccountOrgTimePeriod.endingBalance"
                                 from="((nextGlAccountOrgTimePeriod.endingBalance ?: 0) - (nextGlAccountOrgTimePeriod.beginningBalance ?: 0)) +
                                    lastGlAccountOrgTimePeriod.endingBalance"/>
                            <!-- set next beginningBalance from current endingBalance; do after set next endingBalance because it uses next beginningBalance if there is a value -->
                            <set field="nextGlAccountOrgTimePeriod.beginningBalance" from="lastGlAccountOrgTimePeriod.endingBalance"/>

                            <set field="nextGlAccountOrgTimePeriod.balanceLastUpdated" from="ec.user.nowTimestamp"/>
                            <entity-create value-field="nextGlAccountOrgTimePeriod" or-update="true"/>
                        </iterate>
                    </iterate>
                </iterate>
            </if>

            <check-errors/>

            <!-- do the actual posting: set isPosted to Y and postedDate to now on AcctgTrans, use the EntityValue we already found -->
            <set field="acctgTrans.isPosted" value="Y"/>
            <set field="acctgTrans.postedDate" from="ec.user.nowTimestamp"/>
            <entity-update value-field="acctgTrans"/>
        </actions>
    </service>

    <service verb="post" noun="ReverseAcctgTrans">
        <description>Create a new transaction that is the reverse of the original (for each entry debits to credit and
            vice versa, transaction date set to now, etc).Clones the original transaction so new one will be associated
            with the same invoice, payment, etc.</description>
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="deleteIfNotPosted" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransId" required="true"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>

            <if condition="acctgTrans.isPosted != 'Y'"><if condition="deleteIfNotPosted"><then>
                <service-call name="mantle.ledger.LedgerServices.delete#AcctgTrans" in-map="[acctgTransId:acctgTransId]"/>
                <return/>
            </then><else>
                <return error="true" message="Not reversing transaction [${acctgTransId}], transaction is not posted"/>
            </else></if></if>

            <entity-find entity-name="mantle.ledger.transaction.AcctgTransEntry" list="acctgTransEntryList">
                <econdition field-name="acctgTransId"/><order-by field-name="acctgTransEntrySeqId"/></entity-find>

            <set field="reverseAcctgTrans" from="acctgTrans.clone()"/>
            <set field="reverseAcctgTrans.acctgTransId" from="null"/>
            <entity-sequenced-id-primary value-field="reverseAcctgTrans"/>
            <set field="reverseAcctgTrans.reverseOfAcctgTransId" from="acctgTransId"/>
            <set field="reverseAcctgTrans.transactionDate" from="ec.user.nowTimestamp"/>
            <set field="reverseAcctgTrans.isPosted" value="N"/>
            <entity-create value-field="reverseAcctgTrans"/>

            <set field="reverseAcctgTransId" from="reverseAcctgTrans.acctgTransId"/>

            <set field="useErrorJournal" from="false"/>
            <iterate list="acctgTransEntryList" entry="acctgTransEntry">
                <set field="reverseAcctgTransEntry" from="acctgTransEntry.clone()"/>
                <set field="reverseAcctgTransEntry.acctgTransId" from="reverseAcctgTransId"/>
                <set field="reverseAcctgTransEntry.reconcileStatusId" value="AterNot"/>
                <set field="reverseAcctgTransEntry.debitCreditFlag"
                        from="reverseAcctgTransEntry.debitCreditFlag == 'C' ? 'D' : 'C'"/>
                <entity-create value-field="reverseAcctgTransEntry"/>

                <if condition="!reverseAcctgTransEntry.glAccountId"><set field="useErrorJournal" from="true"/></if>
            </iterate>

            <if condition="useErrorJournal"><then>
                <!-- put in the error journal for the org -->
                <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                        in-map="[organizationPartyId:acctgTrans.organizationPartyId]"/>
                <if condition="partyAcctgPreference?.errorGlJournalId">
                    <service-call name="update#mantle.ledger.transaction.AcctgTrans"
                            in-map="[acctgTransId:reverseAcctgTrans.acctgTransId,
                                glJournalId:partyAcctgPreference.errorGlJournalId]"/>
                </if>
            </then><else>
                <!-- call the post service -->
                <service-call name="mantle.ledger.LedgerServices.post#AcctgTrans" in-map="[acctgTransId:reverseAcctgTransId]"/>
            </else></if>

            <set field="acctgTrans.reversedByAcctgTransId" from="reverseAcctgTransId"/>
            <entity-update value-field="acctgTrans"/>

            <set field="acctgTransId" from="reverseAcctgTransId"/>
        </actions>
    </service>
    <service verb="move" noun="AcctgTransEntry">
        <description>Move a transaction entry from one account to another by posting a transaction reversing the original
            for just the given entry and redoing the original transaction in the other account. Clones the original
            transaction so new one will be associated with the same invoice, payment, etc.</description>
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="acctgTransEntrySeqId" required="true"/>
            <parameter name="glAccountId" required="true"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransId" required="true"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans"/>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTransEntry" value-field="acctgTransEntry"/>

            <if condition="acctgTrans.isPosted != 'Y'">
                <return error="true" message="Not moving transaction entry [${acctgTransId}:${acctgTransEntrySeqId}], transaction is not posted"/></if>
            <if condition="acctgTransEntry.glAccountId == glAccountId">
                <return message="Not moving transaction entry [${acctgTransId}:${acctgTransEntrySeqId}], entry is already posted to account ${glAccountId}"/></if>

            <set field="reverseAcctgTrans" from="acctgTrans.clone()"/>
            <set field="reverseAcctgTrans.acctgTransId" from="null"/>
            <entity-sequenced-id-primary value-field="reverseAcctgTrans"/>
            <set field="reverseAcctgTrans.transactionDate" from="ec.user.nowTimestamp"/>
            <set field="reverseAcctgTrans.isPosted" value="N"/>
            <entity-create value-field="reverseAcctgTrans"/>

            <set field="reverseAcctgTransId" from="reverseAcctgTrans.acctgTransId"/>

            <!-- reverse the original entry -->
            <set field="reverseAcctgTransEntry" from="acctgTransEntry.clone()"/>
            <set field="reverseAcctgTransEntry.acctgTransId" from="reverseAcctgTransId"/>
            <set field="reverseAcctgTransEntry.reconcileStatusId" value="AterNot"/>
            <set field="reverseAcctgTransEntry.debitCreditFlag"
                    from="reverseAcctgTransEntry.debitCreditFlag == 'C' ? 'D' : 'C'"/>
            <entity-create value-field="reverseAcctgTransEntry"/>

            <!-- create new entry in new account -->
            <set field="newAcctgTransEntry" from="acctgTransEntry.clone()"/>
            <set field="newAcctgTransEntry.acctgTransId" from="reverseAcctgTransId"/>
            <set field="newAcctgTransEntry.reconcileStatusId" value="AterNot"/>
            <set field="newAcctgTransEntry.glAccountId" from="glAccountId"/>
            <set field="newAcctgTransEntry.acctgTransEntrySeqId" from="null"/>
            <entity-sequenced-id-secondary value-field="newAcctgTransEntry"/>
            <entity-create value-field="newAcctgTransEntry"/>

            <!-- call the post service -->
            <service-call name="mantle.ledger.LedgerServices.post#AcctgTrans" in-map="[acctgTransId:reverseAcctgTransId]"/>

            <set field="acctgTransId" from="reverseAcctgTransId"/>
        </actions>
    </service>

    <!-- =================================================== -->
    <!-- ========== Financial TimePeriod Services ========== -->
    <!-- =================================================== -->

    <service verb="get" noun="OrganizationFiscalTimePeriods">
        <in-parameters>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="filterDate" type="Timestamp"/>
            <parameter name="timePeriodTypeId"/>
        </in-parameters>
        <out-parameters><parameter name="timePeriodList" type="List"/></out-parameters>
        <actions>
            <!-- NOTE: this one is not recursive, should really have TimePeriod associated with root parent org so just one will match -->
            <set field="filterSqlDate" from="filterDate != null ? new java.sql.Date(filterDate.time) : null"/>
            <entity-find entity-name="mantle.party.time.TimePeriodAndType" list="timePeriodList">
                <!-- doesn't work as needed with date fields (only date-time): <date-filter valid-date="filterSqlDate" ignore-if-empty="true"/> -->
                <econdition field-name="fromDate" operator="less-equals" from="filterSqlDate" ignore-if-empty="true"/>
                <econdition field-name="thruDate" operator="greater-equals" from="filterSqlDate" ignore-if-empty="true"/>
                <econdition field-name="periodPurposeEnumId" value="Fiscal" ignore="timePeriodTypeId"/>
                <econdition field-name="partyId" from="organizationPartyId"/>
                <econdition field-name="timePeriodTypeId" ignore-if-empty="true"/>
            </entity-find>

            <if condition="!timePeriodList">
                <!-- see if a parent org has time periods, if so create for current org based on them -->
                <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                    <date-filter/>
                    <econdition field-name="fromPartyId" from="organizationPartyId"/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                    <econdition field-name="toRoleTypeId" value="OrgInternal"/>
                </entity-find>
                <if condition="partyRelationshipList">
                    <service-call name="mantle.ledger.LedgerServices.get#OrganizationFiscalTimePeriods" out-map="parentPeriodsOut"
                            in-map="[organizationPartyId:partyRelationshipList[0].toPartyId, filterDate:filterDate]"/>
                    <set field="parentOrgPeriodList" from="parentPeriodsOut.timePeriodList"/>

                    <!-- if periods are from a parent org, create clone for this org -->
                    <set field="timePeriodList" from="[]"/>
                    <!-- go through periods largest to smallest to set parent -->
                    <set field="timePeriodTypeIdList" from="['FiscalYear', 'FiscalQuarter', 'FiscalMonth', 'FiscalBiWeek', 'FiscalWeek']"/>
                    <set field="parentPeriodId" from="null"/>
                    <iterate list="timePeriodTypeIdList" entry="timePeriodTypeId">
                        <filter-map-list list="parentOrgPeriodList" to-list="matchPeriodList">
                            <field-map field-name="timePeriodTypeId"/></filter-map-list>

                        <if condition="matchPeriodList">
                            <set field="parentOrgPeriod" from="matchPeriodList[0]"/>
                            <service-call name="mantle.party.TimeServices.getOrCreate#TimePeriod" out-map="createTpOut"
                                    in-map="[partyId:organizationPartyId, timePeriodTypeId:parentOrgPeriod.timePeriodTypeId,
                                        fromDate:parentOrgPeriod.fromDate, parentPeriodId:parentPeriodId]"/>
                            <if condition="!createTpOut.timePeriodId">
                                <return error="true" message="Get or create TimePeriod returned null value for partyId ${partyId}, timePeriodTypeId ${parentOrgPeriod.timePeriodTypeId}, fromDate ${parentOrgPeriod.fromDate}"/></if>
                            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod">
                                <field-map field-name="timePeriodId" from="createTpOut.timePeriodId"/></entity-find-one>
                            <set field="parentPeriodId" from="createTpOut.timePeriodId"/>

                            <if condition="!timePeriodTypeId || timePeriodTypeId == timePeriod.timePeriodTypeId">
                                <script>timePeriodList.add(timePeriod)</script></if>
                        </if>
                    </iterate>
                </if>
            </if>
            <if condition="!timePeriodList">
                <!-- still no time periods for current org, use check#NextFiscalTimePeriods to create -->
                <service-call name="mantle.ledger.LedgerServices.check#NextFiscalTimePeriods"
                        in-map="[organizationPartyId:organizationPartyId, basisDate:filterSqlDate]"/>
                <entity-find entity-name="mantle.party.time.TimePeriodAndType" list="timePeriodList">
                    <econdition field-name="fromDate" operator="less-equals" from="filterSqlDate" ignore-if-empty="true"/>
                    <econdition field-name="thruDate" operator="greater-equals" from="filterSqlDate" ignore-if-empty="true"/>
                    <econdition field-name="periodPurposeEnumId" value="Fiscal" ignore="timePeriodTypeId"/>
                    <econdition field-name="partyId" from="organizationPartyId"/>
                    <econdition field-name="timePeriodTypeId" ignore-if-empty="true"/>
                </entity-find>
            </if>
        </actions>
    </service>
    <service verb="check" noun="NextFiscalTimePeriods">
        <description>
            Ensure that at least current and next TimePeriods exist for FiscalMonth, FiscalQuarter (3 months), FiscalYear.
            If no time periods exist for current date look for most recent and create next.
            If still no time periods exist creates fiscal time periods based on calendar (ie fiscal year matches calendar year).
            If time periods do exist but not next time periods, adds next time period starting next day after current.
            This should be run once per month to ensure the next time period exists.
        </description>
        <in-parameters>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="basisDate" type="java.sql.Date" default="new java.sql.Date(ec.user.nowTimestamp.time)"/>
        </in-parameters>
        <actions>
            <script>basisCal = ec.user.getCalendarSafe(); basisCal.setTime(basisDate)</script>
            <entity-find-one entity-name="mantle.party.Organization" value-field="organization">
                <field-map field-name="partyId" from="organizationPartyId"/></entity-find-one>

            <!-- start with FiscalYear and go down so we have parentPeriodId -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="currentYearList">
                <econdition field-name="fromDate" operator="less-equals" from="basisDate"/>
                <econdition field-name="thruDate" operator="greater-equals" from="basisDate"/>
                <econdition field-name="partyId" from="organizationPartyId"/>
                <econdition field-name="timePeriodTypeId" value="FiscalYear"/>
            </entity-find>
            <if condition="!currentYearList"><then>
                <entity-find entity-name="mantle.party.time.TimePeriod" list="recentPeriodList">
                    <econdition field-name="partyId" from="organizationPartyId"/>
                    <econdition field-name="timePeriodTypeId" value="FiscalYear"/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <if condition="recentPeriodList"><then>
                    <!-- If no current year exists look for most recent and create next until we have current -->
                    <set field="recentPeriod" from="recentPeriodList[0]"/>
                    <while condition="recentPeriod.thruDate &lt; basisDate">
                        <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                                in-map="[previousPeriodId:recentPeriod.timePeriodId]"/>
                        <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="recentPeriod">
                            <field-map field-name="timePeriodId" from="createTpOut.timePeriodId"/></entity-find-one>
                    </while>
                    <set field="yearPeriodId" from="recentPeriod.timePeriodId"/>
                </then><else>
                    <!-- no current year... assume fiscal year is calendar year and create one automatically -->
                    <script>yearFromCal = basisCal.clone(); yearFromCal.set(Calendar.DAY_OF_YEAR, 1)</script>
                    <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                            in-map="[partyId:organizationPartyId, timePeriodTypeId:'FiscalYear',
                                fromDate:new java.sql.Date(yearFromCal.getTimeInMillis())]"/>
                    <set field="yearPeriodId" from="createTpOut.timePeriodId"/>
                </else></if>
            </then><else>
                <set field="yearPeriodId" from="currentYearList[0].timePeriodId"/>
            </else></if>

            <!-- current quarter -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="currentQuarterList">
                <econdition field-name="fromDate" operator="less-equals" from="basisDate"/>
                <econdition field-name="thruDate" operator="greater-equals" from="basisDate"/>
                <econdition field-name="partyId" from="organizationPartyId"/>
                <econdition field-name="timePeriodTypeId" value="FiscalQuarter"/>
            </entity-find>
            <if condition="!currentQuarterList"><then>
                <entity-find entity-name="mantle.party.time.TimePeriod" list="recentPeriodList">
                    <econdition field-name="partyId" from="organizationPartyId"/>
                    <econdition field-name="timePeriodTypeId" value="FiscalQuarter"/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <if condition="recentPeriodList"><then>
                    <!-- If no current quarter exists look for most recent and create next until we have current -->
                    <set field="recentPeriod" from="recentPeriodList[0]"/>
                    <while condition="recentPeriod.thruDate &lt; basisDate">
                        <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                                in-map="[previousPeriodId:recentPeriod.timePeriodId]"/>
                        <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="recentPeriod">
                            <field-map field-name="timePeriodId" from="createTpOut.timePeriodId"/></entity-find-one>
                    </while>
                    <set field="quarterPeriodId" from="recentPeriod.timePeriodId"/>
                </then><else>
                    <!-- no current quarter... assume fiscal year is calendar year with 4 3-month quarters and create one automatically -->
                    <script>quarterNumber = (int) (basisCal.get(Calendar.MONTH)/3)</script>
                    <script>quarterFromCal = basisCal.clone(); quarterFromCal.set(Calendar.MONTH, (quarterNumber * 3)); quarterFromCal.set(Calendar.DAY_OF_MONTH, 1)</script>
                    <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                            in-map="[partyId:organizationPartyId, timePeriodTypeId:'FiscalQuarter',
                                parentPeriodId:yearPeriodId, periodNum:(quarterNumber + 1),
                                fromDate:new java.sql.Date(quarterFromCal.getTimeInMillis())]"/>
                    <set field="quarterPeriodId" from="createTpOut.timePeriodId"/>
                </else></if>
            </then><else>
                <set field="quarterPeriodId" from="currentQuarterList[0].timePeriodId"/>
            </else></if>

            <!-- current month -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="currentMonthList">
                <econdition field-name="fromDate" operator="less-equals" from="basisDate"/>
                <econdition field-name="thruDate" operator="greater-equals" from="basisDate"/>
                <econdition field-name="partyId" from="organizationPartyId"/>
                <econdition field-name="timePeriodTypeId" value="FiscalMonth"/>
            </entity-find>
            <if condition="!currentMonthList"><then>
                <entity-find entity-name="mantle.party.time.TimePeriod" list="recentPeriodList">
                    <econdition field-name="partyId" from="organizationPartyId"/>
                    <econdition field-name="timePeriodTypeId" value="FiscalMonth"/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <if condition="recentPeriodList"><then>
                    <!-- If no current quarter exists look for most recent and create next until we have current -->
                    <set field="recentPeriod" from="recentPeriodList[0]"/>
                    <while condition="recentPeriod.thruDate &lt; basisDate">
                        <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                                in-map="[previousPeriodId:recentPeriod.timePeriodId]"/>
                        <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="recentPeriod">
                            <field-map field-name="timePeriodId" from="createTpOut.timePeriodId"/></entity-find-one>
                    </while>
                    <set field="monthPeriodId" from="recentPeriod.timePeriodId"/>
                </then><else>
                    <!-- no current month... assume fiscal year is calendar year and create one automatically -->
                    <script>monthNumber = basisCal.get(Calendar.MONTH)</script>
                    <script>monthFromCal = basisCal.clone(); monthFromCal.set(Calendar.DAY_OF_MONTH, 1)</script>
                    <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                            in-map="[partyId:organizationPartyId, timePeriodTypeId:'FiscalMonth',
                                parentPeriodId:quarterPeriodId, periodNum:(monthNumber + 1),
                                fromDate:new java.sql.Date(monthFromCal.getTimeInMillis())]"/>
                    <set field="monthPeriodId" from="createTpOut.timePeriodId"/>
                </else></if>
            </then><else>
                <set field="monthPeriodId" from="currentMonthList[0].timePeriodId"/>
            </else></if>

            <!-- next year -->
            <!-- based on current year see if next exists and if not add one starting the day after and one year long -->
            <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="nextYearOut"
                    in-map="[timePeriodId:yearPeriodId]"/>
            <set field="nextYearPeriodId" from="nextYearOut.nextTimePeriodId"/>

            <!-- next quarter, may be in current or next year -->
            <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="nextQuarterOut"
                    in-map="[timePeriodId:quarterPeriodId]"/>
            <set field="nextQuarterPeriodId" from="nextQuarterOut.nextTimePeriodId"/>

            <!-- next month, may be in current or next quarter -->
            <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="nextMonthOut"
                    in-map="[timePeriodId:monthPeriodId]"/>
            <set field="nextMonthPeriodId" from="nextMonthOut.nextTimePeriodId"/>
        </actions>
    </service>

    <service verb="close" noun="FinancialTimePeriod">
        <in-parameters><parameter name="timePeriodId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod" for-update="true"/>
            <set field="fromTimestamp" from="ec.l10n.parseTimestamp(timePeriod.fromDate.toString() + ' 00:00:00.000', 'yyyy-MM-dd HH:mm:ss.SSS')"/>
            <set field="thruTimestamp" from="ec.l10n.parseTimestamp(timePeriod.thruDate.toString() + ' 23:59:59.999', 'yyyy-MM-dd HH:mm:ss.SSS')"/>

            <if condition="timePeriod.isClosed == 'Y'">
                <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, already closed.</message></if>
            <if condition="ec.user.nowTimestamp.before(timePeriod.thruDate)">
                <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, period has not ended (ends on ${timePeriod.thruDate}).</message></if>

            <!-- if any child periods make sure they are closed -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="childTimePeriodList">
                <econdition field-name="parentPeriodId" from="timePeriodId"/>
            </entity-find>
            <iterate list="childTimePeriodList" entry="childTimePeriod"><if condition="childTimePeriod.isClosed != 'Y'">
                <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, child period ${ec.resource.expand('TimePeriodNameTemplate','',childTimePeriod)} not closed.</message>
            </if></iterate>

            <!-- don't allow a period to close if the previous period is not closed -->
            <set field="previousTimePeriod" from="timePeriod.previous"/>
            <if condition="previousTimePeriod &amp;&amp; previousTimePeriod.isClosed != 'Y'">
                <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, previous period ${ec.resource.expand('TimePeriodNameTemplate','',previousTimePeriod)} not closed.</message></if>

            <!-- make sure there are no unposted transactions within the time period -->
            <entity-find-count entity-name="mantle.ledger.transaction.AcctgTrans" count-field="unpostedTransCount">
                <econdition field-name="isPosted" operator="not-equals" value="Y" or-null="true"/>
                <econdition field-name="transactionDate" operator="greater-equals" from="fromTimestamp"/>
                <econdition field-name="transactionDate" operator="less-equals" from="thruTimestamp"/>
            </entity-find-count>
            <if condition="unpostedTransCount &gt; 0">
                <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, found ${unpostedTransCount} in period.</message></if>

            <!-- check errors before continuing -->
            <check-errors/>

            <!-- first close the TimePeriod to avoid further postings -->
            <set field="timePeriod.isClosed" value="Y"/>
            <entity-update value-field="timePeriod"/>

            <!-- recalculate postedDebits, postedCredits, endingBalance on GlAccountOrgTimePeriod records for this time period -->
            <service-call name="mantle.ledger.LedgerServices.recalculate#GlAccountOrgTimePeriodAmounts"
                    in-map="[timePeriodId:timePeriodId]"/>
        </actions>
    </service>
    <service verb="recalculate" noun="GlAccountOrgTimePeriodAmounts">
        <description>Recalculate postedDebits, postedCredits, endingBalance on GlAccountOrgTimePeriod records for a time period</description>
        <in-parameters><parameter name="timePeriodId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod" for-update="true"/>
            <set field="fromTimestamp" from="ec.l10n.parseTimestamp(timePeriod.fromDate.toString() + ' 00:00:00.000', 'yyyy-MM-dd HH:mm:ss.SSS')"/>
            <set field="thruTimestamp" from="ec.l10n.parseTimestamp(timePeriod.thruDate.toString() + ' 23:59:59.999', 'yyyy-MM-dd HH:mm:ss.SSS')"/>

            <!-- get or create the next TimePeriod (gets nextTimePeriodId, nextTimePeriod); always set its begin balance
                from this period's end balance -->
            <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="context"
                    in-map="[timePeriodId:timePeriodId]"/>

            <!-- get any existing subsequent time periods to update those as well (unlike next get only, no create) -->
            <set field="subsequentPeriodIds" from="[nextTimePeriodId]"/>
            <set field="curSubPeriodId" from="nextTimePeriodId"/>
            <script>
            while (curSubPeriodId) {
                Map subNextResult = ec.service.sync().name("mantle.party.TimeServices.get#NextTimePeriod")
                        .parameter("timePeriodId", curSubPeriodId).call()
                curSubPeriodId = subNextResult.nextTimePeriodId
                if (curSubPeriodId) subsequentPeriodIds.add(curSubPeriodId)
            }
            </script>

            <entity-find entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" list="glAccountOrgTimePeriodList" for-update="true">
                <econdition field-name="organizationPartyId" from="timePeriod.partyId"/>
                <econdition field-name="timePeriodId"/>
            </entity-find>
            <iterate list="glAccountOrgTimePeriodList" entry="glAccountOrgTimePeriod">
                <set field="origGlAccountOrgTimePeriod" from="glAccountOrgTimePeriod.cloneValue()"/>

                <entity-find entity-name="mantle.ledger.transaction.AcctgTransAndEntrySummary" list="transSummaryList">
                    <!-- check above makes sure all transactions are posted, so don't filter by here -->
                    <econdition field-name="organizationPartyId" from="timePeriod.partyId"/>
                    <econdition field-name="transactionDate" operator="greater-equals" from="fromTimestamp"/>
                    <econdition field-name="transactionDate" operator="less-equals" from="thruTimestamp"/>
                    <econdition field-name="glAccountId" from="glAccountOrgTimePeriod.glAccountId"/>
                    <select-field field-name="debitCreditFlag"/><select-field field-name="amount"/>
                </entity-find>
                <!-- should have at most 2 results, debitCreditFlag=D, debitCreditFlag=C -->
                <set field="postedDebits" from="0"/><set field="postedCredits" from="0"/>
                <iterate list="transSummaryList" entry="transSummary"><if condition="transSummary.debitCreditFlag == 'D'"><then>
                    <set field="postedDebits" from="transSummary.amount"/>
                </then><else>
                    <set field="postedCredits" from="transSummary.amount"/>
                </else></if></iterate>
                <if condition="postedDebits != glAccountOrgTimePeriod.postedDebits">
                    <set field="glAccountOrgTimePeriod.postedDebits" from="postedDebits"/></if>
                <if condition="postedCredits != glAccountOrgTimePeriod.postedCredits">
                    <set field="glAccountOrgTimePeriod.postedCredits" from="postedCredits"/></if>

                <if condition="glAccountOrgTimePeriod.isModified()">
                    <!-- set the endingBalance based on beginningBalance, postedDebits, postedCredits -->
                    <entity-find-one entity-name="mantle.ledger.account.GlAccount" value-field="glAccount">
                        <field-map field-name="glAccountId" from="glAccountOrgTimePeriod.glAccountId"/></entity-find-one>
                    <service-call name="mantle.ledger.LedgerServices.find#RootGlAccountClassEnum" out-map="context"
                            in-map="[glAccountClassEnumId:glAccount.glAccountClassEnumId]"/>
                    <if condition="rootGlAccountClassEnumId == 'DEBIT'"><then>
                        <set field="glAccountOrgTimePeriod.endingBalance" from="(glAccountOrgTimePeriod.beginningBalance?:0) +
                                (glAccountOrgTimePeriod.postedDebits?:0) - (glAccountOrgTimePeriod.postedCredits?:0)"/>
                    </then><else>
                        <set field="glAccountOrgTimePeriod.endingBalance" from="(glAccountOrgTimePeriod.beginningBalance?:0) -
                                (glAccountOrgTimePeriod.postedDebits?:0) + (glAccountOrgTimePeriod.postedCredits?:0)"/>
                    </else></if>

                    <log level="info" message="In close#FinancialTimePeriod found GlAccountOrgTimePeriod (organizationPartyId=${glAccountOrgTimePeriod.organizationPartyId}, timePeriodId=${glAccountOrgTimePeriod.timePeriodId}, glAccountId=${glAccountOrgTimePeriod.glAccountId}, root class ${rootGlAccountClassEnumId}) with wrong posted amounts; beginningBalance=${glAccountOrgTimePeriod.beginningBalance}, postedDebits was ${origGlAccountOrgTimePeriod.postedDebits} is ${glAccountOrgTimePeriod.postedDebits}, postedCredits was ${origGlAccountOrgTimePeriod.postedCredits} is ${glAccountOrgTimePeriod.postedCredits}, endingBalance was ${origGlAccountOrgTimePeriod.endingBalance} is ${glAccountOrgTimePeriod.endingBalance}"/>
                    <!-- update the record -->
                    <set field="glAccountOrgTimePeriod.balanceLastUpdated" from="ec.user.nowTimestamp"/>
                    <entity-update value-field="glAccountOrgTimePeriod"/>

                    <!-- TODO: also update postedBalance on GlAccountOrganization when we find a difference? -->
                </if>

                <!-- update balances for all existing subsequent periods -->
                <set field="lastGlAccountOrgTimePeriod" from="glAccountOrgTimePeriod"/>
                <iterate list="subsequentPeriodIds" entry="subsequentPeriodId">
                    <!-- for each GlAccountOrgTimePeriod record for current period, set beginning balance for next period
                        (creating new records if they don't exist) -->
                    <entity-find-one entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="nextGlAccountOrgTimePeriod" for-update="true">
                        <field-map field-name="glAccountId" from="glAccountOrgTimePeriod.glAccountId"/>
                        <field-map field-name="organizationPartyId" from="timePeriod.partyId"/>
                        <field-map field-name="timePeriodId" from="subsequentPeriodId"/>
                    </entity-find-one>
                    <if condition="nextGlAccountOrgTimePeriod == null">
                        <entity-make-value entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="nextGlAccountOrgTimePeriod"
                            map="[glAccountId:glAccountOrgTimePeriod.glAccountId,  organizationPartyId:timePeriod.partyId,
                                timePeriodId:subsequentPeriodId, beginningBalance:0, postedDebits:0, postedCredits:0, endingBalance:0]"/>
                    </if>
                    <!-- add endingBalance to both just in case something has already been posted and added to next endingBalance -->
                    <set field="nextGlAccountOrgTimePeriod.endingBalance"
                            from="((nextGlAccountOrgTimePeriod.endingBalance ?: 0) - (nextGlAccountOrgTimePeriod.beginningBalance ?: 0)) +
                                lastGlAccountOrgTimePeriod.endingBalance"/>
                    <!-- set next beginningBalance from current endingBalance; do after set next endingBalance because it uses next beginningBalance if there is a value -->
                    <set field="nextGlAccountOrgTimePeriod.beginningBalance" from="lastGlAccountOrgTimePeriod.endingBalance"/>

                    <set field="nextGlAccountOrgTimePeriod.balanceLastUpdated" from="ec.user.nowTimestamp"/>
                    <entity-create value-field="nextGlAccountOrgTimePeriod" or-update="true"/>

                    <set field="lastGlAccountOrgTimePeriod" from="nextGlAccountOrgTimePeriod"/>
                </iterate>
            </iterate>
        </actions>
    </service>
    <service verb="reopen" noun="FinancialTimePeriod">
        <description>Service for period re-open (with special permission); don't allow reopening a period if the following period is closed</description>
        <in-parameters><parameter name="timePeriodId" required="true"/></in-parameters>
        <actions>
            <if condition="!ec.user.hasPermission('FISCAL_REOPEN')">
                <return error="true" message="Fiscal Period Reopen permission required"/></if>

            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod" for-update="true"/>

            <if condition="timePeriod.isClosed != 'Y'">
                <message error="true">Period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)} is not closed, not reopening.</message></if>

            <!-- don't allow reopening a period if the following period is closed -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="nextPeriodList">
                <econdition field-name="previousPeriodId" from="timePeriodId"/></entity-find>
            <iterate list="nextPeriodList" entry="nextPeriod">
                <if condition="nextPeriod.isClosed == 'Y'">
                    <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, next period ${ec.resource.expand('TimePeriodNameTemplate','',nextPeriod)} is closed.</message></if>
            </iterate>

            <!-- check errors before continuing -->
            <check-errors/>

            <!-- reopen the TimePeriod -->
            <set field="timePeriod.isClosed" value="N"/>
            <entity-update value-field="timePeriod"/>
        </actions>
    </service>

    <service verb="recalculate" noun="GlAccountOrgSummaries" semaphore="fail" semaphore-parameter="organizationPartyId"
             authenticate="anonymous-all" transaction-timeout="600">
        <!-- NOTE: this service is not protected for authz/authc so that it can run in background; don't expose to unprotected access -->
        <in-parameters>
            <parameter name="organizationPartyId"/>
            <parameter name="lastRunTime" type="Timestamp"/>
        </in-parameters>
        <actions>
            <set field="nowTimestamp" from="ec.user.nowTimestamp"/>
            <set field="nowDate" from="new java.sql.Date(nowTimestamp.time)"/>
            <set field="startTime" from="System.currentTimeMillis()"/>
            <set field="gaoUpdated" from="0"/>
            <set field="gaotpUpdated" from="0"/>

            <!-- find all open fiscal TimePeriods and use for GlAccountOrgTimePeriod records -->
            <entity-find entity-name="mantle.party.time.TimePeriodAndType" list="timePeriodList">
                <econdition field-name="fromDate" operator="less-equals" from="nowDate"/><!-- filter future periods, may remove this if future posting allowed -->
                <econdition field-name="periodPurposeEnumId" value="Fiscal"/>
                <econdition field-name="partyId" from="organizationPartyId" ignore-if-empty="true"/>
                <econdition field-name="isClosed" value="N" or-null="true"/><!-- want all past except closed -->
                <order-by field-name="fromDate"/>
            </entity-find>

            <!-- if no organizationPartyId specified find all orgs from open fiscal TimePeriods list (will only have single if specified) -->
            <set field="organizationPartyIds" from="new TreeSet(timePeriodList*.partyId)"/>
            <set field="noTxOrgPartyIds" from="new TreeSet()"/>
            <set field="glAccountRootClassMap" from="[:]"/>

            <!-- for specified or all org create/update GlAccountOrganization.postedBalance -->
            <!-- TODO: consider not doing this and find some other approach... goes back to all posted transactions; we have
                balanceLastUpdated but then would have to do query for each existing GlAccountOrganization record, and then an
                exclude by glAccountId query for the rest; may also not work if previous transactions posted in the still open period -->
            <!-- TODO IDEA: find latest closed period, start with its ending balance and query after its thru date -->
            <iterate list="organizationPartyIds" entry="organizationPartyId">
                <!-- see if there are any transactions since the lastRunTime time (if specified) -->
                <if condition="lastRunTime != null">
                    <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="latestTransList" limit="1">
                        <econdition field-name="organizationPartyId"/>
                        <econdition field-name="isPosted" value="Y"/>
                        <econdition field-name="postedDate" operator="greater-equals" from="lastRunTime"/>
                    </entity-find>
                    <if condition="!latestTransList">
                        <!-- <log level="warn" message="TOREMOVE No transactions newer than ${lastRunTime} for org ${organizationPartyId}, not recalculating summary balances"/> -->
                        <script>noTxOrgPartyIds.add(organizationPartyId)</script>
                        <continue/>
                    </if>
                </if>

                <!-- do the big query to get latest totals -->
                <entity-find entity-name="mantle.ledger.transaction.AcctgTransAndEntrySummary" list="transSummaryList">
                    <econdition field-name="organizationPartyId"/>
                    <econdition field-name="isPosted" value="Y"/>
                    <select-field field-name="glAccountId,debitCreditFlag,amount"/>
                    <order-by field-name="glAccountId,debitCreditFlag"/>
                </entity-find>
                <script><![CDATA[
                    transSummaryListSize = transSummaryList.size()
                    for (int i = 0; i < transSummaryListSize; i++) {
                        Map transSummary = transSummaryList.get(i)
                        String glAccountId = transSummary.glAccountId

                        String rootGlAccountClassEnumId = (String) glAccountRootClassMap.get(glAccountId)
                        if (!rootGlAccountClassEnumId) {
                            Map glAccount = ec.entity.find("mantle.ledger.account.GlAccount").condition("glAccountId", glAccountId).useCache(true).one()
                            rootGlAccountClassEnumId = ec.service.sync().name("mantle.ledger.LedgerServices.find#RootGlAccountClassEnum")
                                    .parameter("glAccountClassEnumId", glAccount.glAccountClassEnumId).call().rootGlAccountClassEnumId
                        }
                        boolean isDebitAccount = 'DEBIT'.equals(rootGlAccountClassEnumId)

                        Map debitTransSummary = null
                        boolean isCredit = transSummary.debitCreditFlag == 'C'
                        if (isCredit && (i + 1) < transSummaryListSize) {
                            debitTransSummary = transSummaryList.get(i + 1)
                            if (debitTransSummary.debitCreditFlag == 'D' && debitTransSummary.glAccountId == glAccountId) {
                                i++
                            } else {
                                debitTransSummary = null
                            }
                        }

                        Map glAccountOrganization = ec.entity.find("mantle.ledger.account.GlAccountOrganization")
                                .condition("glAccountId", glAccountId).condition("organizationPartyId", organizationPartyId)
                                .forUpdate(true).one()
                        if (glAccountOrganization == null) {
                            glAccountOrganization = ec.entity.makeValue("mantle.ledger.account.GlAccountOrganization")
                            glAccountOrganization.put("glAccountId", glAccountId)
                            glAccountOrganization.put("organizationPartyId", organizationPartyId)
                            glAccountOrganization.create()
                        }

                        BigDecimal postedBalance = BigDecimal.ZERO
                        if (isCredit) {
                            // based on account type add/subtract credit
                            if (isDebitAccount) postedBalance -= transSummary.amount
                            else postedBalance += transSummary.amount
                            // if debitTransSummary != null based on account type subtract/add debit
                            if (debitTransSummary != null) {
                                if (isDebitAccount) postedBalance += debitTransSummary.amount
                                else postedBalance -= debitTransSummary.amount
                            }
                        } else {
                            // based on account type subtract/add debit
                            if (isDebitAccount) postedBalance += transSummary.amount
                            else postedBalance -= transSummary.amount
                        }

                        glAccountOrganization.put("postedBalance", postedBalance)
                        glAccountOrganization.put("balanceLastUpdated", nowTimestamp)
                        glAccountOrganization.update()
                        gaoUpdated++
                    }
                ]]></script>
            </iterate>

            <iterate list="timePeriodList" entry="timePeriod">
                <if condition="noTxOrgPartyIds.contains(timePeriod.partyId)"><continue/></if>

                <set field="timePeriodId" from="timePeriod.timePeriodId"/>
                <set field="organizationPartyId" from="timePeriod.partyId"/>
                <set field="fromTimestamp" from="ec.l10n.parseTimestamp(timePeriod.fromDate.toString() + ' 00:00:00.000', 'yyyy-MM-dd HH:mm:ss.SSS')"/>
                <set field="thruTimestamp" from="ec.l10n.parseTimestamp(timePeriod.thruDate.toString() + ' 23:59:59.999', 'yyyy-MM-dd HH:mm:ss.SSS')"/>

                <!-- get or create the next TimePeriod (gets nextTimePeriodId, nextTimePeriod); always set its begin balance
                    from this period's end balance -->
                <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="context"
                              in-map="[timePeriodId:timePeriodId]"/>

                <!-- get any existing subsequent time periods to update those as well (unlike next get only, no create) -->
                <set field="subsequentPeriodIds" from="[nextTimePeriodId]"/>
                <set field="curSubPeriodId" from="nextTimePeriodId"/>
                <script>
                    while (curSubPeriodId) {
                        Map subNextResult = ec.service.sync().name("mantle.party.TimeServices.get#NextTimePeriod")
                                .parameter("timePeriodId", curSubPeriodId).call()
                        curSubPeriodId = subNextResult.nextTimePeriodId
                        if (curSubPeriodId) subsequentPeriodIds.add(curSubPeriodId)
                    }
                </script>

                <entity-find entity-name="mantle.ledger.transaction.AcctgTransAndEntrySummary" list="transSummaryList">
                    <econdition field-name="organizationPartyId"/>
                    <econdition field-name="transactionDate" operator="greater-equals" from="fromTimestamp"/>
                    <econdition field-name="transactionDate" operator="less-equals" from="thruTimestamp"/>
                    <econdition field-name="isPosted" value="Y"/>
                    <select-field field-name="glAccountId,debitCreditFlag,amount"/>
                    <order-by field-name="glAccountId,debitCreditFlag"/>
                </entity-find>
                <script><![CDATA[
                    transSummaryListSize = transSummaryList.size()
                    for (int i = 0; i < transSummaryListSize; i++) {
                        Map transSummary = transSummaryList.get(i)
                        String glAccountId = transSummary.glAccountId

                        String rootGlAccountClassEnumId = (String) glAccountRootClassMap.get(glAccountId)
                        if (!rootGlAccountClassEnumId) {
                            Map glAccount = ec.entity.find("mantle.ledger.account.GlAccount").condition("glAccountId", glAccountId).useCache(true).one()
                            rootGlAccountClassEnumId = ec.service.sync().name("mantle.ledger.LedgerServices.find#RootGlAccountClassEnum")
                                    .parameter("glAccountClassEnumId", glAccount.glAccountClassEnumId).call().rootGlAccountClassEnumId
                        }
                        boolean isDebitAccount = 'DEBIT'.equals(rootGlAccountClassEnumId)

                        Map debitTransSummary = null
                        boolean isCredit = transSummary.debitCreditFlag == 'C'
                        if (isCredit && (i + 1) < transSummaryListSize) {
                            debitTransSummary = transSummaryList.get(i + 1)
                            if (debitTransSummary.debitCreditFlag == 'D' && debitTransSummary.glAccountId == glAccountId) {
                                i++
                            } else {
                                debitTransSummary = null
                            }
                        }

                        Map glAccountOrgTimePeriod = ec.entity.find("mantle.ledger.account.GlAccountOrgTimePeriod")
                                .condition("glAccountId", glAccountId).condition("organizationPartyId", organizationPartyId)
                                .condition("timePeriodId", timePeriodId).forUpdate(true).one()
                        if (glAccountOrgTimePeriod == null) {
                            glAccountOrgTimePeriod = ec.entity.makeValue("mantle.ledger.account.GlAccountOrgTimePeriod")
                            glAccountOrgTimePeriod.put("glAccountId", glAccountId)
                            glAccountOrgTimePeriod.put("organizationPartyId", organizationPartyId)
                            glAccountOrgTimePeriod.put("timePeriodId", timePeriodId)
                            glAccountOrgTimePeriod.put("beginningBalance", BigDecimal.ZERO)
                            glAccountOrgTimePeriod.create()
                        }

                        BigDecimal postedDebits = BigDecimal.ZERO
                        BigDecimal postedCredits = BigDecimal.ZERO
                        if (isCredit) {
                            postedCredits += transSummary.amount
                            if (debitTransSummary != null) postedDebits += debitTransSummary.amount
                        } else {
                            postedDebits += transSummary.amount
                        }

                        // calculate endingBalance from beginningBalance and posted debits/credits
                        BigDecimal beginningBalance = glAccountOrgTimePeriod.beginningBalance ?: BigDecimal.ZERO
                        BigDecimal endingBalance
                        if (isDebitAccount) endingBalance = beginningBalance + postedDebits - postedCredits
                        else endingBalance = beginningBalance - postedDebits + postedCredits

                        glAccountOrgTimePeriod.put("postedDebits", postedDebits)
                        glAccountOrgTimePeriod.put("postedCredits", postedCredits)
                        glAccountOrgTimePeriod.put("endingBalance", endingBalance)
                        glAccountOrgTimePeriod.put("balanceLastUpdated", nowTimestamp)
                        glAccountOrgTimePeriod.update()
                        gaotpUpdated++

                        // update balances for all existing subsequent periods
                        Map lastGlAccountOrgTimePeriod = glAccountOrgTimePeriod
                        for (String subsequentPeriodId in subsequentPeriodIds) {
                            Map nextGlAccountOrgTimePeriod = ec.entity.find("mantle.ledger.account.GlAccountOrgTimePeriod")
                                    .condition("glAccountId", glAccountId).condition("organizationPartyId", organizationPartyId)
                                    .condition("timePeriodId", subsequentPeriodId).forUpdate(true).one()
                            if (nextGlAccountOrgTimePeriod == null) {
                                nextGlAccountOrgTimePeriod = ec.entity.makeValue("mantle.ledger.account.GlAccountOrgTimePeriod")
                                nextGlAccountOrgTimePeriod.put("glAccountId", glAccountId)
                                nextGlAccountOrgTimePeriod.put("organizationPartyId", organizationPartyId)
                                nextGlAccountOrgTimePeriod.put("timePeriodId", subsequentPeriodId)
                                nextGlAccountOrgTimePeriod.put("beginningBalance", BigDecimal.ZERO)
                                nextGlAccountOrgTimePeriod.put("postedDebits", BigDecimal.ZERO)
                                nextGlAccountOrgTimePeriod.put("postedCredits", BigDecimal.ZERO)
                                nextGlAccountOrgTimePeriod.put("endingBalance", BigDecimal.ZERO)
                                nextGlAccountOrgTimePeriod.create()
                            }

                            nextGlAccountOrgTimePeriod.put("endingBalance", ((nextGlAccountOrgTimePeriod.endingBalance ?: 0) -
                                    (nextGlAccountOrgTimePeriod.beginningBalance ?: 0)) + lastGlAccountOrgTimePeriod.endingBalance)
                            nextGlAccountOrgTimePeriod.put("beginningBalance", lastGlAccountOrgTimePeriod.endingBalance)
                            nextGlAccountOrgTimePeriod.put("balanceLastUpdated", nowTimestamp)
                            nextGlAccountOrgTimePeriod.update()

                            lastGlAccountOrgTimePeriod = nextGlAccountOrgTimePeriod
                        }
                    }
                ]]></script>
            </iterate>

            <log level="info" message="Updated GL Account Org Summaries for orgs ${organizationPartyIds} in ${System.currentTimeMillis() - startTime}ms; updated ${gaoUpdated} GlAccountOrganization and ${gaotpUpdated} GlAccountOrgTimePeriod records"/>
        </actions>
    </service>

    <!-- ========================================= -->
    <!-- ========== GL Journal Services ========== -->
    <!-- ========================================= -->

    <service verb="create" noun="GlJournal">
        <in-parameters>
            <auto-parameters include="nonpk"><exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
            <parameter name="glJournalName" required="true"/>
        </in-parameters>
        <out-parameters><parameter name="glJournalId"/></out-parameters>
        <actions>
            <set field="isPosted" value="N"/>
            <service-call name="create#mantle.ledger.transaction.GlJournal" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="GlJournal">
        <in-parameters>
            <parameter name="glJournalId" required="true"/>
            <auto-parameters include="nonpk"><exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
        </in-parameters>
        <actions>
            <service-call name="update#mantle.ledger.transaction.GlJournal" in-map="context"/>
        </actions>
    </service>

    <!-- is this even needed for anything?
    <service verb="calculate" noun="GlJournalTrialBalance">
        <in-parameters><parameter name="glJournalId" required="true"/></in-parameters>
        <out-parameters>
            <parameter name="debitTotal" type="BigDecimal"/>
            <parameter name="creditTotal" type="BigDecimal"/>
            <parameter name="debitCreditDifference" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <!- - implement this...? - ->
        </actions>
    </service>
    -->
    <service verb="post" noun="GlJournal">
        <description>Posts a GL Journal (GlJournal) by posting each transaction (AcctgTrans) in the journal.</description>
        <in-parameters>
            <parameter name="glJournalId" required="true"/>
            <parameter name="closeJournal" type="Boolean" default="false"/>
        </in-parameters>
        <actions>
            <!-- lock the Journal first -->
            <entity-find-one entity-name="mantle.ledger.transaction.GlJournal" value-field="glJournal" for-update="true"/>

            <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="acctgTransList">
                <econdition field-name="glJournalId"/><order-by field-name="acctgTransId"/>
            </entity-find>
            <set field="txPostCount" from="0"/>
            <iterate list="acctgTransList" entry="acctgTrans">
                <service-call name="mantle.ledger.LedgerServices.post#AcctgTrans"
                        in-map="[acctgTransId:acctgTrans.acctgTransId]"/>
                <if condition="ec.message.hasError()"><then><return error="true"/></then>
                    <else><set field="txPostCount" from="txPostCount + 1"/></else></if>
            </iterate>
            <message>Posted ${txPostCount} transactions</message>

            <if condition="closeJournal">
                <set field="glJournal.isPosted" value="Y"/>
                <set field="glJournal.postedDate" from="ec.user.nowTimestamp"/>
                <entity-update value-field="glJournal"/>
            </if>
        </actions>
    </service>
</services>
